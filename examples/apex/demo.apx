import math;
import nats;
import nats.btoi;
import nats.is_prime as prime;
import fractions;
import fractions.decimal_to_fraction as to_fraction;
import asm;
import mem;
import async;
import fs;
import os;
import net;
import proc;
import signal;

fn weighted_score(value) {
    var score = nats.gcd(value, 192);
    let curvature = math.sqrt(144);
    let trig = math.sin(math.pi() / 4);
    score = score * 2 + curvature;
    return score + nats.sum_digits(value) + math.pow(trig, 2);
}

fn apex() {
    let signed = -270;
    let base = nats.abs_value(signed);
    let enriched = weighted_score(base);
    let divisor_score = nats.divisors_count(base);
    let twin = btoi(nats.is_twin_prime(29));
    let sophie = btoi(nats.is_sophie_germain_prime(23));
    let kaprekar = btoi(nats.is_kaprekar(45));
    let wilson = btoi(nats.wilson_theorem(13));
    let fermat = btoi(nats.fermat_little(5, 97));
    let kaprekar_proof = btoi(nats.kaprekar_theorem(3524));
    let kaprekar_steps = nats.kaprekar_6174_steps(3524);
    let kaprekar_constant = nats.kaprekar_constant();
    let bonus = btoi(prime(97));
    let energy = math.hypot(3, 4);
    let smooth = math.abs(-3.5);
    let goldbach_pair = nats.goldbach_witness(84);
    let goldbach_ok = btoi(nats.goldbach_holds(84));
    let ramanujan = nats.ramanujan_pairs(1729);
    let taxicab = btoi(nats.is_taxicab_number(1729));
    let mersenne = nats.mersenne_number(7);
    let mersenne_prime = btoi(nats.is_mersenne_prime(7));
    let bertrand_witness = nats.bertrand_prime(50);
    let bertrand_ok = btoi(nats.bertrand_postulate(50));
    let euler = btoi(nats.euler_totient_theorem(7, 40));
    let gauss = nats.gauss_sum(25);
    let gauss_ok = btoi(nats.gauss_sum_identity(25));
    let triangular = nats.triangular_number(divisor_score);
    let figurate = nats.pentagonal_number(5) + nats.hexagonal_number(4);
    let catalan = nats.catalan_number(5);
    let catalan_ok = btoi(nats.catalan_theorem(5));
    let nicomachus = btoi(nats.nicomachus_theorem(25));
    let happy = nats.happy_steps(19);
    let automorphic = btoi(nats.is_automorphic(76));
    let pal = btoi(nats.is_palindromic(12321));
    let triple = btoi(nats.pythagorean_triple(3, 4, 5));
    let pell = nats.pell_number(10);
    let pell_lucas = nats.pell_lucas_number(10);
    let pell_id = btoi(nats.pell_theorem(10));
    let pell_solution = btoi(nats.pell_equation(577, 408));
    let sylvester = nats.sylvester_number(4);
    let sylvester_ok = btoi(nats.sylvester_identity(4));
    let ruth_aaron = btoi(nats.is_ruth_aaron_pair(714, 715));
    let highly = btoi(nats.is_highly_composite(12));
    let perfect_totient = btoi(nats.is_perfect_totient(9));
    let sphenic = btoi(nats.is_sphenic(30));
    let semiperfect = btoi(nats.is_semiperfect(20));
    let weird = btoi(nats.is_weird(70));
    let refactorable = btoi(nats.is_refactorable(24));
    let pernicious = btoi(nats.is_pernicious(17));
    let smith = btoi(nats.is_smith_number(666));
    let collatz = nats.collatz_steps(27);
    let collatz_peak = nats.collatz_peak(27);
    let lucky_value = nats.lucky_number(10);
    let lucky_flag = btoi(nats.is_lucky_number(21));
    let bell = nats.bell_number(5);
    let pointer = mem.alloc_bytes(6);
    let wipe = btoi(mem.memset(pointer, 0xaa, 3));
    let pointer_slot = mem.pointer_offset(pointer, 1);
    let copy_ok = btoi(mem.memcpy(pointer_slot, pointer, 2));
    let block_bytes = fractions.fraction_add(1, 2, 1, 2);
    let block_ok = btoi(mem.write_block(pointer, block_bytes));
    let block_read = mem.read_block(pointer, 2);
    let block_first = mem.tuple_get(block_read, 0);
    let checksum = mem.checksum(pointer, 2);
    let find_index = mem.find_byte(pointer, 1);
    let compare_flag = mem.compare(pointer, pointer_slot, 2);
    mem.write_byte(pointer_slot, 42);
    let byte = mem.read_byte(pointer_slot);
    let swap_flag = btoi(mem.swap_ranges(pointer, pointer_slot, 1));
    let reverse_flag = btoi(mem.reverse_block(pointer, 2));
    let pattern_flag = btoi(mem.fill_pattern(pointer_slot, block_read, 1));
    let counted = mem.count_byte(pointer, 3, 0xaa);
    let rotate = mem.binary_rotate_left(0b1011, 2);
    let toggle = mem.bit_toggle(rotate, 3);
    let bit_flag = btoi(mem.bit_test(toggle, 1));
    let bit_count = mem.bit_count(toggle);
    let smart = mem.smart_pointer_new(byte);
    let smart_value = mem.smart_pointer_get(smart);
    let asm_regs = asm.inline("mov r0, 5; add r0, 7; xor r1, 0x3;");
    let asm_acc = mem.tuple_get(asm_regs, 0);
    let task = async.spawn("sum", 100);
    let task_result_value = async.join(task);
    let mailbox = async.mailbox_create();
    async.mailbox_send(mailbox, task_result_value);
    let echoed_task = async.mailbox_recv(mailbox);
    async.mailbox_send(mailbox, smart_value);
    let timed = async.mailbox_recv_timeout(mailbox, 0);
    async.mailbox_send(mailbox, timed);
    async.sleep_ms(0);
    let pending_mail = async.mailbox_len(mailbox);
    let drained_mail = async.mailbox_drain(mailbox);
    let drain_value = mem.tuple_get(drained_mail, 0);
    let try_mail = async.mailbox_try_recv(mailbox);
    let try_flag = btoi(mem.tuple_get(try_mail, 0));
    let close_flag = btoi(async.mailbox_close(mailbox));
    let closed_flag = btoi(async.mailbox_is_closed(mailbox));
    let cwd = os.cwd();
    let tmp_dir = os.temp_dir();
    let env_path = os.env_var("PATH");
    let path_ok = mem.tuple_get(env_path, 0);
    let env_flag = btoi(path_ok);
    let output_path = "apex_demo_output.txt";
    fs.write_text(output_path, "apex demo file");
    let file_flag = btoi(fs.file_exists(output_path));
    let file_text = fs.read_text(output_path);
    fs.write_bytes(output_path, fractions.fraction_egyptian_terms(1, 2));
    let copy_path = "apex_demo_copy.txt";
    let copy_bytes = fs.copy(output_path, copy_path);
    let file_meta = fs.metadata(copy_path);
    let meta_flag = btoi(mem.tuple_get(file_meta, 1));
    let renamed_path = "apex_demo_copy_renamed.txt";
    fs.rename(copy_path, renamed_path);
    let dir_path = "apex_demo_dir";
    fs.mkdir_all(dir_path);
    let dir_meta = fs.metadata(dir_path);
    let dir_flag = btoi(mem.tuple_get(dir_meta, 2));
    let touch_flag = btoi(fs.touch(output_path));
    let temp_file = fs.tempfile("apex_demo");
    let tree_listing = fs.read_tree(".");
    let listing = fs.list_dir(cwd);
    let listing_flag = btoi(mem.tuple_get(listing, 0) == mem.tuple_get(listing, 0));
    let tree_flag = btoi(mem.tuple_get(tree_listing, 0) == ".");
    fs.delete(output_path);
    fs.delete(renamed_path);
    let temp_delete_flag = btoi(fs.delete(temp_file));
    let pid = os.pid();
    let args = os.args();
    let args_flag = btoi(mem.tuple_get(args, 0) == mem.tuple_get(args, 0));
    let which = proc.which("sh");
    let which_flag = btoi(mem.tuple_get(which, 0));
    let process_info = proc.run("sh", "-c", "echo apex");
    let proc_env = proc.env_get("PATH");
    let proc_env_flag = btoi(mem.tuple_get(proc_env, 0));
    let env_set_flag = btoi(proc.env_set("APEX_DEMO_FLAG", "ready"));
    let proc_env_list = proc.env_list();
    let proc_env_list_flag = btoi(mem.tuple_get(proc_env_list, 0) == mem.tuple_get(proc_env_list, 0));
    let proc_args = proc.args();
    let proc_args_flag = btoi(mem.tuple_get(proc_args, 0) == mem.tuple_get(proc_args, 0));
    let proc_cwd = proc.cwd();
    let _ = proc.set_cwd(dir_path);
    let proc_cwd_after = proc.cwd();
    let _ = proc.set_cwd(proc_cwd);
    let proc_cwd_flag = btoi(proc_cwd_after != proc_cwd);
    fs.delete(dir_path);
    signal.register("USR1");
    let signal_hits = signal.emit("USR1");
    signal.reset("USR1");
    let tracked = signal.tracked();
    let private_flag = btoi(net.is_private_ipv4("10.0.0.1"));
    let addresses = net.resolve_host("localhost");
    let net_network = net.ipv4_network("10.0.1.5", 16);
    let net_broadcast = net.ipv4_broadcast("10.0.1.5", 24);
    let net_flag = btoi(net_network == "10.0.0.0");
    let broadcast_flag = btoi(net_broadcast == "10.0.1.255");
    let cidr_flag = btoi(net.cidr_contains("10.0.0.0/8", "10.1.2.3"));
    let loopback_flag = btoi(net.is_loopback("127.0.0.1"));
    let net_class_flag = btoi(net.ipv4_class("224.0.0.1") == "D");
    let net_int = net.ipv4_to_int("192.168.0.1");
    let net_back = net.int_to_ipv4(net_int);
    let net_back_flag = btoi(net_back == "192.168.0.1");
    let binary_mask = mem.binary_and(0xff, 170);
    let shift = mem.binary_shift_left(3, 5);
    let tuple_exit = mem.tuple_get(process_info, 0);
    let classroom_ratio = fractions.fraction_add(1, 3, 1, 6);
    let ratio_decimal = fractions.fraction_to_decimal(classroom_ratio);
    let ratio_num = fractions.fraction_numerator(classroom_ratio);
    let ratio_den = fractions.fraction_denominator(classroom_ratio);
    let ratio_proper = btoi(fractions.fraction_is_proper(classroom_ratio));
    let ratio_terminating = btoi(fractions.fraction_is_terminating(classroom_ratio));
    let ratio_period = fractions.fraction_period_length(classroom_ratio);
    let benchmark = to_fraction(0.8125, 256);
    let benchmark_decimal = fractions.fraction_to_decimal(benchmark);
    let mediant = fractions.fraction_mediant(classroom_ratio, benchmark);
    let mediant_decimal = fractions.fraction_to_decimal(mediant);
    let mediant_neighbors = btoi(fractions.fraction_farey_neighbors(classroom_ratio, benchmark));
    let reciprocal = fractions.fraction_reciprocal(benchmark);
    let reciprocal_decimal = fractions.fraction_to_decimal(reciprocal);
    let continued = fractions.fraction_continued_terms(benchmark, 5);
    let rebuilt_frac = fractions.fraction_from_continued(continued);
    let limited_frac = fractions.fraction_limit_denominator(benchmark, 10);
    let approx_target = fractions.fraction_add(22, 7, 0, 1);
    let continued_flag = btoi(rebuilt_frac == benchmark);
    let limited_flag = btoi(limited_frac == approx_target);
    let reduced_flag = btoi(fractions.fraction_is_reduced(classroom_ratio));
    let compare_value = fractions.fraction_compare(classroom_ratio, benchmark);
    let ratio_mixed = fractions.fraction_to_mixed(classroom_ratio);
    let rebuilt = fractions.fraction_from_mixed(mem.tuple_get(ratio_mixed, 0), mem.tuple_get(ratio_mixed, 1), mem.tuple_get(ratio_mixed, 2));
    let rebuilt_num = mem.tuple_get(rebuilt, 0);
    let decimal_parts = fractions.fraction_decimal_parts(benchmark);
    let decimal_flag = btoi(mem.tuple_get(decimal_parts, 2) == mem.tuple_get(decimal_parts, 2));
    return enriched + bonus + energy + smooth + divisor_score + twin + sophie + kaprekar + wilson + fermat + kaprekar_proof + kaprekar_steps + goldbach_pair + goldbach_ok + ramanujan / 2 + taxicab + mersenne_prime + mersenne / 127 + kaprekar_constant / 6174 + bertrand_witness / 53 + bertrand_ok + euler + gauss / 55 + gauss_ok + triangular / 55 + figurate / 63 + catalan / 42 + catalan_ok + nicomachus + happy + automorphic + pal + triple + pell / 1000 + pell_lucas / 1000 + pell_id + pell_solution + sylvester / 2000 + sylvester_ok + ruth_aaron + highly + perfect_totient + sphenic + semiperfect + weird + refactorable + pernicious + smith + collatz / 50 + collatz_peak / 100 + lucky_value / 25 + lucky_flag + bell / 100 + ratio_decimal + ratio_num + ratio_den + ratio_proper + ratio_terminating + ratio_period / 10.0 + benchmark_decimal + mediant_decimal + mediant_neighbors + reciprocal_decimal + smart_value + asm_acc + task_result_value + echoed_task + timed + try_flag + binary_mask + shift + tuple_exit + file_flag + signal_hits + tracked + env_flag + listing_flag + tree_flag + pid + args_flag + which_flag + private_flag + loopback_flag + net_class_flag + net_back_flag + wipe + copy_ok + bit_flag + bit_count + block_first + checksum + find_index + compare_flag + block_ok + swap_flag + reverse_flag + pattern_flag + counted + pending_mail + drain_value + close_flag + closed_flag + copy_bytes + meta_flag + dir_flag + touch_flag + temp_delete_flag + proc_env_flag + proc_env_list_flag + proc_args_flag + env_set_flag + proc_cwd_flag + net_flag + broadcast_flag + cidr_flag + reduced_flag + compare_value + rebuilt_num + decimal_flag + continued_flag + limited_flag;
}
