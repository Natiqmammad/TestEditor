import math;
import nats;
import nats.btoi;
import nats.is_prime as prime;
import fractions;
import fractions.decimal_to_fraction as to_fraction;
import structs;
import serde;
import asm;
import mem;
import async;
import fs;
import os;
import net;
import proc;
import signal;

fn weighted_score(value) {
    var score = nats.gcd(value, 192);
    let curvature = math.sqrt(144);
    let trig = math.sin(math.pi() / 4);
    score = score * 2 + curvature;
    return score + nats.sum_digits(value) + math.pow(trig, 2);
}

fn apex() {
    let signed = -270;
    let base = nats.abs_value(signed);
    let enriched = weighted_score(base);
    let divisor_score = nats.divisors_count(base);
    let twin = btoi(nats.is_twin_prime(29));
    let sophie = btoi(nats.is_sophie_germain_prime(23));
    let kaprekar = btoi(nats.is_kaprekar(45));
    let wilson = btoi(nats.wilson_theorem(13));
    let fermat = btoi(nats.fermat_little(5, 97));
    let kaprekar_proof = btoi(nats.kaprekar_theorem(3524));
    let kaprekar_steps = nats.kaprekar_6174_steps(3524);
    let kaprekar_constant = nats.kaprekar_constant();
    let bonus = btoi(prime(97));
    let energy = math.hypot(3, 4);
    let smooth = math.abs(-3.5);
    let goldbach_pair = nats.goldbach_witness(84);
    let goldbach_ok = btoi(nats.goldbach_holds(84));
    let ramanujan = nats.ramanujan_pairs(1729);
    let taxicab = btoi(nats.is_taxicab_number(1729));
    let mersenne = nats.mersenne_number(7);
    let mersenne_prime = btoi(nats.is_mersenne_prime(7));
    let bertrand_witness = nats.bertrand_prime(50);
    let bertrand_ok = btoi(nats.bertrand_postulate(50));
    let euler = btoi(nats.euler_totient_theorem(7, 40));
    let gauss = nats.gauss_sum(25);
    let gauss_ok = btoi(nats.gauss_sum_identity(25));
    let triangular = nats.triangular_number(divisor_score);
    let figurate = nats.pentagonal_number(5) + nats.hexagonal_number(4);
    let catalan = nats.catalan_number(5);
    let catalan_ok = btoi(nats.catalan_theorem(5));
    let nicomachus = btoi(nats.nicomachus_theorem(25));
    let happy = nats.happy_steps(19);
    let automorphic = btoi(nats.is_automorphic(76));
    let pal = btoi(nats.is_palindromic(12321));
    let triple = btoi(nats.pythagorean_triple(3, 4, 5));
    let pell = nats.pell_number(10);
    let pell_lucas = nats.pell_lucas_number(10);
    let pell_id = btoi(nats.pell_theorem(10));
    let pell_solution = btoi(nats.pell_equation(577, 408));
    let sylvester = nats.sylvester_number(4);
    let sylvester_ok = btoi(nats.sylvester_identity(4));
    let ruth_aaron = btoi(nats.is_ruth_aaron_pair(714, 715));
    let highly = btoi(nats.is_highly_composite(12));
    let perfect_totient = btoi(nats.is_perfect_totient(9));
    let sphenic = btoi(nats.is_sphenic(30));
    let semiperfect = btoi(nats.is_semiperfect(20));
    let weird = btoi(nats.is_weird(70));
    let refactorable = btoi(nats.is_refactorable(24));
    let pernicious = btoi(nats.is_pernicious(17));
    let smith = btoi(nats.is_smith_number(666));
    let collatz = nats.collatz_steps(27);
    let collatz_peak = nats.collatz_peak(27);
    let lucky_value = nats.lucky_number(10);
    let lucky_flag = btoi(nats.is_lucky_number(21));
    let bell = nats.bell_number(5);
    let pointer = mem.alloc_bytes(48);
    let wipe = btoi(mem.memset(pointer, 170, 3));
    let pointer_slot = mem.pointer_offset(pointer, 1);
    let copy_ok = btoi(mem.memcpy(pointer_slot, pointer, 2));
    let block_bytes = fractions.fraction_add(1, 2, 1, 2);
    let percent_value = fractions.fraction_to_percent(1, 4);
    let percent_flag = btoi(math.abs(percent_value - 25.0) < 0.1);
    let repeating_tuple = fractions.fraction_from_decimal_pattern("0", "", "3");
    let repeat_num = mem.tuple_get(repeating_tuple, 0);
    let repeat_den = mem.tuple_get(repeating_tuple, 1);
    let block_ok = btoi(mem.write_block(pointer, block_bytes));
    let block_read = mem.read_block(pointer, 2);
    let block_first = mem.tuple_get(block_read, 0);
    let checksum = mem.checksum(pointer, 2);
    let find_index = mem.find_byte(pointer, 1);
    let compare_flag = mem.compare(pointer, pointer_slot, 2);
    mem.write_byte(pointer_slot, 42);
    let byte = mem.read_byte(pointer_slot);
    let swap_flag = btoi(mem.swap_ranges(pointer, pointer_slot, 1));
    let reverse_flag = btoi(mem.reverse_block(pointer, 2));
    let pattern_flag = btoi(mem.fill_pattern(pointer_slot, block_read, 1));
    let counted = mem.count_byte(pointer, 3, 170);
    let rotate = mem.binary_rotate_left(11, 2);
    let toggle = mem.bit_toggle(rotate, 3);
    let bit_flag = btoi(mem.bit_test(toggle, 1));
    let bit_count = mem.bit_count(toggle);
    let word_write = btoi(mem.write_u32_le(pointer, 4277009102));
    let word_value = mem.read_u32_le(pointer);
    let be_write = btoi(mem.write_u32_be(pointer, 2882400001));
    let be_value = mem.read_u32_be(pointer);
    let wide_be_write = btoi(mem.write_u64_be(pointer, 72623859790382856));
    let wide_be_value = mem.read_u64_be(pointer);
    let huge_write = btoi(mem.write_u128_le(pointer, 1339673755198158349044581307228491536));
    let huge_value = mem.read_u128_le(pointer);
    let huge_be_write = btoi(mem.write_u128_be(pointer, 22690724228668807036942595891182575392));
    let huge_be_value = mem.read_u128_be(pointer);
    let float_seed = mem.read_f32_le(pointer);
    mem.write_f32_le(pointer, 3.25);
    let float_round = mem.read_f32_le(pointer);
    mem.write_f64_be(pointer, 42.5);
    let float_wide = mem.read_f64_be(pointer);
    let pattern_seek = mem.find_pattern(pointer, block_read);
    let seek_flag = btoi(pattern_seek >= 0);
    let dump_text = mem.hexdump(pointer, 4);
    let dump_flag = btoi(dump_text == dump_text);
    let halfword_value = mem.read_u16_le(pointer);
    let wide_ok = btoi(mem.write_u64_le(pointer, 72623859790382856));
    let wide_value = mem.read_u64_le(pointer);
    let pointer_delta = mem.pointer_diff(pointer_slot, pointer);
    let smart = mem.smart_pointer_new(byte);
    let smart_value = mem.smart_pointer_get(smart);
    let smart_clone = mem.smart_pointer_clone(smart);
    let clone_value = mem.smart_pointer_get(smart_clone);
    let smart_freed = btoi(mem.smart_pointer_free(smart));
    let smart_free_again = btoi(mem.smart_pointer_free(smart));
    let asm_regs = asm.inline("mov r0, 5; add r0, 7; xor r1, 0x3;");
    let asm_acc = mem.tuple_get(asm_regs, 0);
    let task = async.spawn("sum", 100);
    let task_result_value = async.join(task);
    let mailbox = async.mailbox_create();
    async.mailbox_send(mailbox, task_result_value);
    let echoed_task = async.mailbox_recv(mailbox);
    async.mailbox_send(mailbox, smart_value);
    let timed = async.mailbox_recv_timeout(mailbox, 0);
    async.mailbox_send(mailbox, timed);
    let sum_handle = async.spawn("sum", 20);
    let fib_handle = async.spawn("fibonacci", 10);
    let joined_bundle = async.join_all(sum_handle, fib_handle);
    let joined_a = mem.tuple_get(joined_bundle, 0);
    let joined_b = mem.tuple_get(joined_bundle, 1);
    async.sleep_ms(0);
    let pending_mail = async.mailbox_len(mailbox);
    let drained_mail = async.mailbox_drain(mailbox);
    let drain_value = mem.tuple_get(drained_mail, 0);
    let try_mail = async.mailbox_try_recv(mailbox);
    let try_flag = btoi(mem.tuple_get(try_mail, 0));
    let backup_mail = async.mailbox_create();
    async.mailbox_send(mailbox, 77);
    let forwarded = async.mailbox_forward(mailbox, backup_mail);
    async.mailbox_send(mailbox, 123);
    let batch_sent = async.mailbox_send_batch(backup_mail, block_read);
    let any_pair = async.mailbox_recv_any(mailbox, backup_mail);
    let any_handle_tuple = mem.tuple_get(any_pair, 0);
    let any_handle_id = mem.tuple_get(any_handle_tuple, 0);
    let any_value = mem.tuple_get(any_pair, 1);
    let backup_pending = async.mailbox_len(backup_mail);
    let batch_bundle = async.mailbox_recv_batch(backup_mail, 1);
    let stats_bundle = async.mailbox_stats(backup_mail);
    async.mailbox_send(backup_mail, 91);
    let flush_bundle = async.mailbox_flush(backup_mail);
    let stats_pending = mem.tuple_get(stats_bundle, 0);
    let stats_closed = mem.tuple_get(stats_bundle, 1);
    let stats_closed_flag = btoi(stats_closed);
    let flush_flag = btoi(mem.tuple_get(flush_bundle, 1));
    let batch_value = mem.tuple_get(batch_bundle, 0);
    let closed_flag = btoi(async.mailbox_is_closed(mailbox));
    let close_flag = btoi(async.mailbox_close(mailbox));
    let cancel_handle = async.spawn("sleep_ms", 0);
    let cancel_flag = btoi(async.cancel(cancel_handle));
    let cwd = os.cwd();
    let tmp_dir = os.temp_dir();
    let env_path = os.env_var("PATH");
    let path_ok = mem.tuple_get(env_path, 0);
    let env_flag = btoi(path_ok);
    let output_path = "apex_demo_output.txt";
    fs.write_text(output_path, "apex demo file");
    let file_flag = btoi(fs.file_exists(output_path));
    let file_text = fs.read_text(output_path);
    let file_bytes = fs.file_size(output_path);
    fs.write_bytes(output_path, fractions.fraction_egyptian_terms(1, 2));
    let copy_path = "apex_demo_copy.txt";
    let copy_bytes = fs.copy(output_path, copy_path);
    let file_meta = fs.metadata(copy_path);
    let meta_flag = btoi(mem.tuple_get(file_meta, 1));
    let renamed_path = "apex_demo_copy_renamed.txt";
    fs.rename(copy_path, renamed_path);
    let lines_path = "apex_demo_lines.txt";
    fs.write_lines(lines_path, "alpha", "beta", "gamma");
    let lines_tuple = fs.read_lines(lines_path);
    let lines_flag = btoi(mem.tuple_get(lines_tuple, 0) == "alpha");
    let dir_bytes = fs.dir_size(".");
    let dir_path = "apex_demo_dir";
    fs.mkdir_all(dir_path);
    let dir_meta = fs.metadata(dir_path);
    let dir_flag = btoi(mem.tuple_get(dir_meta, 2));
    let type_dir_flag = btoi(fs.is_dir(dir_path));
    let touch_flag = btoi(fs.touch(output_path));
    let temp_file = fs.tempfile("apex_demo");
    let tree_listing = fs.read_tree(".");
    let listing = fs.list_dir(cwd);
    let listing_flag = btoi(mem.tuple_get(listing, 0) == mem.tuple_get(listing, 0));
    let tree_flag = btoi(mem.tuple_get(tree_listing, 0) == ".");
    let tree_src = "apex_demo_tree";
    fs.mkdir_all(tree_src);
    let tree_child = tree_src + "/nested";
    fs.mkdir_all(tree_child);
    let tree_file = tree_child + "/note.txt";
    fs.write_text(tree_file, "tree data");
    let tree_dest = "apex_demo_tree_copy";
    let dir_copy_count = fs.copy_dir(tree_src, tree_dest);
    let path_parts = fs.path_components(tree_dest);
    let joined_tree = fs.path_join(tree_src, "nested", "note.txt");
    let relative_note = fs.relative_path(tree_src, tree_file);
    let walk_listing = fs.walk_files(tree_src);
    let symlink_tuple = fs.symlink_target(output_path);
    let canonical_copy = fs.canonicalize(tree_dest);
    let canonical_flag = btoi(canonical_copy == canonical_copy);
    let join_flag = btoi(joined_tree == tree_file);
    let relative_flag = btoi(relative_note == "nested/note.txt");
    let walk_flag = btoi(mem.tuple_get(walk_listing, 0) == "nested/note.txt");
    let type_file_flag = btoi(fs.is_file(output_path));
    fs.delete(output_path);
    fs.delete(renamed_path);
    fs.delete(lines_path);
    fs.delete(tree_src);
    fs.delete(tree_dest);
    let temp_delete_flag = btoi(fs.delete(temp_file));
    let path_component_flag = btoi(mem.tuple_get(path_parts, 0) == tree_dest);
    let symlink_flag = btoi(mem.tuple_get(symlink_tuple, 0));
    let pid = os.pid();
    let args = os.args();
    let args_flag = btoi(mem.tuple_get(args, 0) == mem.tuple_get(args, 0));
    let which = proc.which("sh");
    let which_flag = btoi(mem.tuple_get(which, 0));
    let uuid_value = proc.uuid_v4();
    let exe_path = proc.exe_path();
    let uuid_flag = btoi(uuid_value == uuid_value);
    let exe_flag = btoi(exe_path == exe_path);
    let process_info = proc.run("sh", "-c", "echo apex");
    let proc_env = proc.env_get("PATH");
    let proc_env_flag = btoi(mem.tuple_get(proc_env, 0));
    let env_set_flag = btoi(proc.env_set("APEX_DEMO_FLAG", "ready"));
    let proc_env_list = proc.env_list();
    let proc_env_list_flag = btoi(mem.tuple_get(proc_env_list, 0) == mem.tuple_get(proc_env_list, 0));
    let env_remove_flag = btoi(proc.env_remove("APEX_DEMO_FLAG"));
    let runtime_pid = proc.pid();
    let runtime_ppid = proc.ppid();
    let host_label = proc.hostname();
    let host_flag = btoi(host_label == host_label);
    let proc_args = proc.args();
    let proc_args_flag = btoi(mem.tuple_get(proc_args, 0) == mem.tuple_get(proc_args, 0));
    let proc_cwd = proc.cwd();
    let proc_temp = proc.temp_dir();
    let proc_home = proc.home_dir();
    let user_seed = btoi(proc.env_set("USER", "apex_user"));
    let proc_user = proc.username();
    let username_flag = btoi(proc_user == proc_user);
    let temp_flag = btoi(proc_temp == proc_temp);
    let home_flag = btoi(proc_home == proc_home);
    proc.set_cwd(dir_path);
    let proc_cwd_after = proc.cwd();
    proc.set_cwd(proc_cwd);
    let proc_cwd_flag = btoi(proc_cwd_after != proc_cwd);
    fs.delete(dir_path);
    signal.register("USR1");
    let signal_hits = signal.emit("USR1");
    signal.reset("USR1");
    let tracked = signal.tracked();
    let private_flag = btoi(net.is_private_ipv4("10.0.0.1"));
    let addresses = net.resolve_host("localhost");
    let net_network = net.ipv4_network("10.0.1.5", 16);
    let net_broadcast = net.ipv4_broadcast("10.0.1.5", 24);
    let net_flag = btoi(net_network == "10.0.0.0");
    let broadcast_flag = btoi(net_broadcast == "10.0.1.255");
    let cidr_flag = btoi(net.cidr_contains("10.0.0.0/8", "10.1.2.3"));
    let loopback_flag = btoi(net.is_loopback("127.0.0.1"));
    let net_class_flag = btoi(net.ipv4_class("224.0.0.1") == "D");
    let net_int = net.ipv4_to_int("192.168.0.1");
    let net_back = net.int_to_ipv4(net_int);
    let net_back_flag = btoi(net_back == "192.168.0.1");
    let next_ip = net.ipv4_next("10.0.0.1");
    let prev_ip = net.ipv4_prev(next_ip);
    let host_pool = net.ipv4_host_count(24);
    let ptr_label = net.reverse_ptr("10.0.0.5");
    let multicast_flag = btoi(net.is_multicast("239.1.2.3"));
    let ip_walk_flag = btoi(prev_ip == "10.0.0.1");
    let ptr_flag = btoi(ptr_label == ptr_label);
    let next_flag = btoi(next_ip != prev_ip);
    let mask_bits = net.mask_to_prefix("255.255.0.0");
    let range_tuple = net.ipv4_range("10.0.1.0/24");
    let supernet_label = net.ipv4_supernet("10.0.1.0/24");
    let split_tuple = net.cidr_split("10.0.0.0/23");
    let binary_ip = net.ipv4_to_binary("10.0.0.1");
    let link_local_flag = btoi(net.is_link_local("169.254.1.1"));
    let same_subnet_flag = btoi(net.ipv4_same_subnet("10.0.0.1", "10.0.0.200", 24));
    let overlap_flag = btoi(net.cidr_overlap("10.0.0.0/24", "10.0.0.128/25"));
    let range_flag = btoi(mem.tuple_get(range_tuple, 0) == "10.0.1.0");
    let binary_flag = btoi(binary_ip == binary_ip);
    let supernet_flag = btoi(supernet_label == "10.0.0.0/23");
    let split_flag = btoi(mem.tuple_get(split_tuple, 1) == "10.0.1.0/24");
    let binary_mask = mem.binary_and(255, 170);
    let shift = mem.binary_shift_left(3, 5);
    let tuple_exit = mem.tuple_get(process_info, 0);
    let struct_seed = serde.from_json("{\"name\":\"apex\",\"value\":42}");
    let struct_copy = structs.copy(struct_seed);
    let struct_clone = structs.clone_tuple(struct_seed);
    let struct_update = serde.from_json("{\"value\":84}");
    let struct_patch_entry = mem.tuple_get(struct_update, 0);
    let struct_patch = structs.copy_replace(struct_clone, 1, struct_patch_entry);
    let struct_chain = structs.tuple_concat(struct_seed, struct_patch);
    let struct_deep = structs.deep_clone(struct_chain);
    let struct_appended = structs.copy_append(struct_deep, ("extra", 99));
    let struct_copy_flag = btoi(struct_copy == struct_seed);
    let struct_patch_flag = btoi(mem.tuple_get(struct_patch, 1) != mem.tuple_get(struct_seed, 1));
    let struct_concat_flag = btoi(mem.tuple_get(struct_chain, 2) == mem.tuple_get(struct_patch, 0));
    let serde_json_text = serde.to_json(struct_seed);
    let serde_round = serde.from_json(serde_json_text);
    let serde_pretty = serde.pretty_json(struct_seed);
    let serde_bytes = serde.to_bytes(struct_seed);
    let serde_bytes_round = serde.from_bytes(serde_bytes);
    let serde_xml_text = serde.to_xml(struct_seed);
    let serde_xml_round = serde.from_xml(serde_xml_text);
    let serde_yaml_text = serde.to_yaml(struct_seed);
    let serde_yaml_round = serde.from_yaml(serde_yaml_text);
    let serde_csv_text = serde.to_csv(((1, "alpha"), (2, "beta")));
    let serde_csv_round = serde.from_csv(serde_csv_text);
    let serde_score = btoi(serde_round == struct_seed) + btoi(serde_bytes_round == struct_seed) + btoi(serde_xml_round == struct_seed) + btoi(serde_yaml_round == struct_seed) + btoi(mem.tuple_get(serde_csv_round, 0) == (1, "alpha"));
    let serde_format_flag = btoi(serde_pretty == serde_pretty) + btoi(struct_appended != struct_chain);
    let classroom_ratio = fractions.fraction_add(1, 3, 1, 6);
    let ratio_decimal = fractions.fraction_to_decimal(classroom_ratio);
    let ratio_num = fractions.fraction_numerator(classroom_ratio);
    let ratio_den = fractions.fraction_denominator(classroom_ratio);
    let ratio_proper = btoi(fractions.fraction_is_proper(classroom_ratio));
    let ratio_terminating = btoi(fractions.fraction_is_terminating(classroom_ratio));
    let ratio_period = fractions.fraction_period_length(classroom_ratio);
    let benchmark = to_fraction(0.8125, 256);
    let benchmark_decimal = fractions.fraction_to_decimal(benchmark);
    let mediant = fractions.fraction_mediant(classroom_ratio, benchmark);
    let mediant_decimal = fractions.fraction_to_decimal(mediant);
    let mediant_neighbors = btoi(fractions.fraction_farey_neighbors(classroom_ratio, benchmark));
    let reciprocal = fractions.fraction_reciprocal(benchmark);
    let reciprocal_decimal = fractions.fraction_to_decimal(reciprocal);
    let decimal_cycle = fractions.fraction_decimal_cycle(classroom_ratio);
    let convergent_list = fractions.fraction_convergents(classroom_ratio, 2);
    let reptend_flag = btoi(fractions.fraction_full_reptend(7));
    let decimal_cycle_flag = btoi(mem.tuple_get(decimal_cycle, 2) == mem.tuple_get(decimal_cycle, 2));
    let convergent_flag = btoi(mem.tuple_get(convergent_list, 0) == mem.tuple_get(convergent_list, 0));
    let continued = fractions.fraction_continued_terms(benchmark, 5);
    let rebuilt_frac = fractions.fraction_from_continued(continued);
    let limited_frac = fractions.fraction_limit_denominator(benchmark, 10);
    let approx_target = fractions.fraction_add(22, 7, 0, 1);
    let continued_flag = btoi(rebuilt_frac == benchmark);
    let limited_flag = btoi(limited_frac == approx_target);
    let reduced_flag = btoi(fractions.fraction_is_reduced(classroom_ratio));
    let compare_value = fractions.fraction_compare(classroom_ratio, benchmark);
    let ratio_mixed = fractions.fraction_to_mixed(classroom_ratio);
    let rebuilt = fractions.fraction_from_mixed(mem.tuple_get(ratio_mixed, 0), mem.tuple_get(ratio_mixed, 1), mem.tuple_get(ratio_mixed, 2));
    let rebuilt_num = mem.tuple_get(rebuilt, 0);
    let decimal_parts = fractions.fraction_decimal_parts(benchmark);
    let decimal_flag = btoi(mem.tuple_get(decimal_parts, 2) == mem.tuple_get(decimal_parts, 2));
    return enriched + bonus + energy + smooth + divisor_score + twin + sophie + kaprekar + wilson + fermat + kaprekar_proof + kaprekar_steps + goldbach_pair + goldbach_ok + ramanujan / 2 + taxicab + mersenne_prime + mersenne / 127 + kaprekar_constant / 6174 + bertrand_witness / 53 + bertrand_ok + euler + gauss / 55 + gauss_ok + triangular / 55 + figurate / 63 + catalan / 42 + catalan_ok + nicomachus + happy + automorphic + pal + triple + pell / 1000 + pell_lucas / 1000 + pell_id + pell_solution + sylvester / 2000 + sylvester_ok + ruth_aaron + highly + perfect_totient + sphenic + semiperfect + weird + refactorable + pernicious + smith + collatz / 50 + collatz_peak / 100 + lucky_value / 25 + lucky_flag + bell / 100 + ratio_decimal + ratio_num + ratio_den + ratio_proper + ratio_terminating + ratio_period / 10.0 + benchmark_decimal + mediant_decimal + mediant_neighbors + reciprocal_decimal + smart_value + asm_acc + task_result_value + echoed_task + timed + try_flag + binary_mask + shift + tuple_exit + file_flag + signal_hits + tracked + env_flag + listing_flag + tree_flag + pid + args_flag + which_flag + private_flag + loopback_flag + net_class_flag + net_back_flag + ptr_flag + next_flag + wipe + copy_ok + bit_flag + bit_count + block_first + checksum + find_index + compare_flag + block_ok + swap_flag + reverse_flag + pattern_flag + counted + pending_mail + drain_value + close_flag + closed_flag + copy_bytes + meta_flag + dir_flag + touch_flag + temp_delete_flag + proc_env_flag + proc_env_list_flag + proc_args_flag + env_set_flag + user_seed + proc_cwd_flag + net_flag + broadcast_flag + cidr_flag + reduced_flag + compare_value + rebuilt_num + decimal_flag + continued_flag + limited_flag + word_write + word_value / 1000000 + seek_flag + dump_flag + joined_a / 100 + joined_b / 100 + forwarded + backup_pending + lines_flag + dir_bytes / 1000000 + multicast_flag + ip_walk_flag + host_pool / 100000 + host_flag + runtime_pid / 1000 + runtime_ppid / 1000 + halfword_value + wide_value / 1000000000000 + pointer_delta + wide_ok + batch_value + flush_flag + cancel_flag + path_component_flag + symlink_flag + env_remove_flag + dir_copy_count / 10 + mask_bits + range_flag + binary_flag + link_local_flag + decimal_cycle_flag + convergent_flag + reptend_flag + temp_flag + home_flag
        + type_dir_flag + type_file_flag + canonical_flag + be_write + be_value / 1000000 + wide_be_write + wide_be_value / 1000000000000
        + huge_write + huge_value / 1000000000000000000000000000000000 + huge_be_write + huge_be_value / 1000000000000000000000000000000000
        + stats_pending + stats_closed_flag + supernet_flag + split_flag + uuid_flag + exe_flag
        + percent_value / 25 + percent_flag + repeat_num + repeat_den + file_bytes / 100
        + batch_sent + any_handle_id / 10 + any_value + join_flag + relative_flag + walk_flag
        + same_subnet_flag + overlap_flag + username_flag
        + clone_value + smart_freed + smart_free_again
        + struct_copy_flag + struct_patch_flag + struct_concat_flag
        + serde_score + serde_format_flag;
}
