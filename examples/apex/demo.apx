import math;
import nats;
import nats.btoi;
import nats.is_prime as prime;
import fractions;
import fractions.decimal_to_fraction as to_fraction;
import asm;
import memory;
import concurrency;
import filesystem;
import os;
import network;
import process;
import signal;

fn weighted_score(value) {
    var score = nats.gcd(value, 192);
    let curvature = math.sqrt(144);
    let trig = math.sin(math.pi() / 4);
    score = score * 2 + curvature;
    return score + nats.sum_digits(value) + math.pow(trig, 2);
}

fn apex() {
    let signed = -270;
    let base = nats.abs_value(signed);
    let enriched = weighted_score(base);
    let divisor_score = nats.divisors_count(base);
    let twin = btoi(nats.is_twin_prime(29));
    let sophie = btoi(nats.is_sophie_germain_prime(23));
    let kaprekar = btoi(nats.is_kaprekar(45));
    let wilson = btoi(nats.wilson_theorem(13));
    let fermat = btoi(nats.fermat_little(5, 97));
    let kaprekar_proof = btoi(nats.kaprekar_theorem(3524));
    let kaprekar_steps = nats.kaprekar_6174_steps(3524);
    let kaprekar_constant = nats.kaprekar_constant();
    let bonus = btoi(prime(97));
    let energy = math.hypot(3, 4);
    let smooth = math.abs(-3.5);
    let goldbach_pair = nats.goldbach_witness(84);
    let goldbach_ok = btoi(nats.goldbach_holds(84));
    let ramanujan = nats.ramanujan_pairs(1729);
    let taxicab = btoi(nats.is_taxicab_number(1729));
    let mersenne = nats.mersenne_number(7);
    let mersenne_prime = btoi(nats.is_mersenne_prime(7));
    let bertrand_witness = nats.bertrand_prime(50);
    let bertrand_ok = btoi(nats.bertrand_postulate(50));
    let euler = btoi(nats.euler_totient_theorem(7, 40));
    let gauss = nats.gauss_sum(25);
    let gauss_ok = btoi(nats.gauss_sum_identity(25));
    let triangular = nats.triangular_number(divisor_score);
    let figurate = nats.pentagonal_number(5) + nats.hexagonal_number(4);
    let catalan = nats.catalan_number(5);
    let catalan_ok = btoi(nats.catalan_theorem(5));
    let nicomachus = btoi(nats.nicomachus_theorem(25));
    let happy = nats.happy_steps(19);
    let automorphic = btoi(nats.is_automorphic(76));
    let pal = btoi(nats.is_palindromic(12321));
    let triple = btoi(nats.pythagorean_triple(3, 4, 5));
    let pell = nats.pell_number(10);
    let pell_lucas = nats.pell_lucas_number(10);
    let pell_id = btoi(nats.pell_theorem(10));
    let pell_solution = btoi(nats.pell_equation(577, 408));
    let sylvester = nats.sylvester_number(4);
    let sylvester_ok = btoi(nats.sylvester_identity(4));
    let ruth_aaron = btoi(nats.is_ruth_aaron_pair(714, 715));
    let highly = btoi(nats.is_highly_composite(12));
    let perfect_totient = btoi(nats.is_perfect_totient(9));
    let sphenic = btoi(nats.is_sphenic(30));
    let semiperfect = btoi(nats.is_semiperfect(20));
    let weird = btoi(nats.is_weird(70));
    let refactorable = btoi(nats.is_refactorable(24));
    let pernicious = btoi(nats.is_pernicious(17));
    let smith = btoi(nats.is_smith_number(666));
    let collatz = nats.collatz_steps(27);
    let collatz_peak = nats.collatz_peak(27);
    let lucky_value = nats.lucky_number(10);
    let lucky_flag = btoi(nats.is_lucky_number(21));
    let bell = nats.bell_number(5);
    let pointer = memory.alloc_bytes(6);
    let wipe = btoi(memory.memset(pointer, 0xaa, 3));
    let pointer_slot = memory.pointer_offset(pointer, 1);
    let copy_ok = btoi(memory.memcpy(pointer_slot, pointer, 2));
    memory.write_byte(pointer_slot, 42);
    let byte = memory.read_byte(pointer_slot);
    let rotate = memory.binary_rotate_left(0b1011, 2);
    let toggle = memory.bit_toggle(rotate, 3);
    let bit_flag = btoi(memory.bit_test(toggle, 1));
    let bit_count = memory.bit_count(toggle);
    let smart = memory.smart_pointer_new(byte);
    let smart_value = memory.smart_pointer_get(smart);
    let asm_regs = asm.inline("mov r0, 5; add r0, 7; xor r1, 0x3;");
    let asm_acc = memory.tuple_get(asm_regs, 0);
    let task = concurrency.spawn("sum", 100);
    let task_result_value = concurrency.join(task);
    let mailbox = concurrency.mailbox_create();
    concurrency.mailbox_send(mailbox, task_result_value);
    let echoed_task = concurrency.mailbox_recv(mailbox);
    let try_mail = concurrency.mailbox_try_recv(mailbox);
    let try_flag = btoi(memory.tuple_get(try_mail, 0));
    let cwd = os.cwd();
    let tmp_dir = os.temp_dir();
    let env_path = os.env_var("PATH");
    let path_ok = memory.tuple_get(env_path, 0);
    let env_flag = btoi(path_ok);
    let output_path = "apex_demo_output.txt";
    filesystem.write_text(output_path, "apex demo file");
    let file_flag = btoi(filesystem.file_exists(output_path));
    let file_text = filesystem.read_text(output_path);
    filesystem.write_bytes(output_path, fractions.fraction_egyptian_terms(1, 2));
    let listing = filesystem.list_dir(cwd);
    let listing_flag = btoi(memory.tuple_get(listing, 0) == memory.tuple_get(listing, 0));
    filesystem.delete(output_path);
    let pid = os.pid();
    let args = os.args();
    let args_flag = btoi(memory.tuple_get(args, 0) == memory.tuple_get(args, 0));
    let which = process.which("sh");
    let which_flag = btoi(memory.tuple_get(which, 0));
    let process_info = process.run("sh", "-c", "echo apex");
    signal.register("USR1");
    let signal_hits = signal.emit("USR1");
    signal.reset("USR1");
    let tracked = signal.tracked();
    let private_flag = btoi(network.is_private_ipv4("10.0.0.1"));
    let addresses = network.resolve_host("localhost");
    let binary_mask = memory.binary_and(0xff, 170);
    let shift = memory.binary_shift_left(3, 5);
    let tuple_exit = memory.tuple_get(process_info, 0);
    let classroom_ratio = fractions.fraction_add(1, 3, 1, 6);
    let ratio_decimal = fractions.fraction_to_decimal(classroom_ratio);
    let ratio_num = fractions.fraction_numerator(classroom_ratio);
    let ratio_den = fractions.fraction_denominator(classroom_ratio);
    let ratio_proper = btoi(fractions.fraction_is_proper(classroom_ratio));
    let ratio_terminating = btoi(fractions.fraction_is_terminating(classroom_ratio));
    let ratio_period = fractions.fraction_period_length(classroom_ratio);
    let benchmark = to_fraction(0.8125, 256);
    let benchmark_decimal = fractions.fraction_to_decimal(benchmark);
    let mediant = fractions.fraction_mediant(classroom_ratio, benchmark);
    let mediant_decimal = fractions.fraction_to_decimal(mediant);
    let mediant_neighbors = btoi(fractions.fraction_farey_neighbors(classroom_ratio, benchmark));
    let reciprocal = fractions.fraction_reciprocal(benchmark);
    let reciprocal_decimal = fractions.fraction_to_decimal(reciprocal);
    return enriched + bonus + energy + smooth + divisor_score + twin + sophie + kaprekar + wilson + fermat + kaprekar_proof + kaprekar_steps + goldbach_pair + goldbach_ok + ramanujan / 2 + taxicab + mersenne_prime + mersenne / 127 + kaprekar_constant / 6174 + bertrand_witness / 53 + bertrand_ok + euler + gauss / 55 + gauss_ok + triangular / 55 + figurate / 63 + catalan / 42 + catalan_ok + nicomachus + happy + automorphic + pal + triple + pell / 1000 + pell_lucas / 1000 + pell_id + pell_solution + sylvester / 2000 + sylvester_ok + ruth_aaron + highly + perfect_totient + sphenic + semiperfect + weird + refactorable + pernicious + smith + collatz / 50 + collatz_peak / 100 + lucky_value / 25 + lucky_flag + bell / 100 + ratio_decimal + ratio_num + ratio_den + ratio_proper + ratio_terminating + ratio_period / 10.0 + benchmark_decimal + mediant_decimal + mediant_neighbors + reciprocal_decimal + smart_value + asm_acc + task_result_value + echoed_task + try_flag + binary_mask + shift + tuple_exit + file_flag + signal_hits + tracked + env_flag + listing_flag + pid + args_flag + which_flag + private_flag + wipe + copy_ok + bit_flag + bit_count;
}
