//! ApexForge NightScript Compiler
//! 
//! A hybrid programming language for system programming and high-level applications.

mod lexer;
mod parser;
mod ast;
mod type_system;
mod codegen;
mod interpreter;
mod flutter_integration;
mod apexlang;

// AFNS Standard Library Integration
#[cfg(feature = "forge")]
mod forge;

use codegen::CodeGenerator;

use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;
use anyhow::Result;

/// ApexForge NightScript Compiler
#[derive(Parser)]
#[command(name = "afns")]
#[command(about = "ApexForge NightScript Compiler")]
#[command(version = "0.1.0")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build AFNS source files
    Build {
        /// Input source file
        #[arg(short, long)]
        input: PathBuf,
        
        /// Output file
        #[arg(short = 'o', long)]
        output: Option<PathBuf>,
        
        /// Target platform (native, wasm, bytecode)
        #[arg(short = 't', long, default_value = "native")]
        target: String,
        
        /// Optimization level (0-3)
        #[arg(short = 'O', long, default_value = "1")]
        opt_level: u8,
    },
    
    /// Run AFNS source files directly
    Run {
        /// Source file to run
        input: PathBuf,
        
        /// Arguments to pass to the program
        args: Vec<String>,
    },
    
    /// Format AFNS source files
    Fmt {
        /// Files to format
        files: Vec<PathBuf>,
        
        /// Check formatting without modifying files
        #[arg(long)]
        check: bool,
    },
    
    /// Run tests
    Test {
        /// Test files or directories
        files: Vec<PathBuf>,
        
        /// Run tests in parallel
        #[arg(long)]
        parallel: bool,
    },
    
    /// Check syntax without building
    Check {
        /// Files to check
        files: Vec<PathBuf>,
    },

    /// Evaluate APEXLANG source files
    Apex {
        /// ApexLang source file to evaluate
        #[arg(short, long)]
        input: PathBuf,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Build { input, output, target, opt_level } => {
            build_command(input, output, target, opt_level)
        }
        Commands::Run { input, args } => {
            run_command(input, args)
        }
        Commands::Fmt { files, check } => {
            fmt_command(files, check)
        }
        Commands::Test { files, parallel } => {
            test_command(files, parallel)
        }
        Commands::Check { files } => {
            check_command(files)
        }
        Commands::Apex { input } => apex_command(input),
    }
}

fn build_command(
    input: PathBuf,
    output: Option<PathBuf>,
    target: String,
    opt_level: u8,
) -> Result<()> {
    println!("Building AFNS source: {:?}", input);
    println!("Target: {}", target);
    println!("Optimization level: {}", opt_level);
    
    // Read source file
    let source = fs::read_to_string(&input)?;
    
    // Lex the source
    let tokens: Vec<_> = lexer::PositionalLexer::new(&source).collect();
    println!("Lexed {} tokens", tokens.len());
    
    // Parse the source
    let mut parser = parser::Parser::new(tokens);
    let ast = parser.parse()?;
    println!("Parsed AST with {} items", ast.items.len());
    
    // Generate output filename if not provided
    let output_path = output.unwrap_or_else(|| {
        let mut path = input.clone();
        path.set_extension(match target.as_str() {
            "wasm" => "wasm",
            "bytecode" => "afbc",
            _ => "exe",
        });
        path
    });
    
    // Generate code based on target
    match target.as_str() {
        "native" => {
            println!("Generating LLVM IR: {:?}", output_path);
            let mut llvm_gen = codegen::LLVMCodeGenerator::new();
            let llvm_ir = llvm_gen.generate_ir(&ast)?;
            fs::write(&output_path, llvm_ir)?;
            println!("Generated LLVM IR successfully!");
        }
        "wasm" => {
            println!("Generating WASM module: {:?}", output_path);
            let mut wasm_gen = codegen::WASMCodeGenerator;
            let wasm_code = wasm_gen.generate(&ast)?;
            fs::write(&output_path, wasm_code)?;
            println!("Generated WASM successfully!");
        }
        "bytecode" => {
            println!("Generating AFNS bytecode: {:?}", output_path);
            let mut bytecode_gen = codegen::BytecodeGenerator;
            let bytecode = bytecode_gen.generate(&ast)?;
            fs::write(&output_path, bytecode)?;
            println!("Generated bytecode successfully!");
        }
        _ => {
            return Err(anyhow::anyhow!("Unsupported target: {}", target));
        }
    }
    
    println!("Build completed successfully!");
    Ok(())
}

fn run_command(input: PathBuf, args: Vec<String>) -> Result<()> {
    println!("Running AFNS source: {:?}", input);
    if !args.is_empty() {
        println!("Arguments: {:?}", args);
    }
    
    // Read source file
    let source = fs::read_to_string(&input)?;
    
    // Lex the source
    let tokens: Vec<_> = lexer::PositionalLexer::new(&source).collect();
    
    // Parse the source
    let mut parser = parser::Parser::new(tokens);
    let ast = parser.parse()?;
    
    println!("AST parsed successfully with {} items", ast.items.len());
    
    // Simple AFNS Interpreter
    interpreter::interpret_program(&ast)?;
    
    Ok(())
}

fn fmt_command(files: Vec<PathBuf>, check: bool) -> Result<()> {
    if files.is_empty() {
        println!("No files specified for formatting");
        return Ok(());
    }
    
    if check {
        println!("Checking formatting for {} files", files.len());
    } else {
        println!("Formatting {} files", files.len());
    }
    
    for file in files {
        if !file.exists() {
            eprintln!("Warning: File {:?} does not exist", file);
            continue;
        }
        
        let source = fs::read_to_string(&file)?;
        
        // TODO: Implement AFNS formatter
        println!("Processing file: {:?}", file);
        
        if !check {
            // TODO: Write formatted source back to file
            println!("Formatted: {:?}", file);
        }
    }
    
    Ok(())
}

fn test_command(files: Vec<PathBuf>, parallel: bool) -> Result<()> {
    println!("Running tests");
    if parallel {
        println!("Running tests in parallel");
    }
    
    if files.is_empty() {
        println!("No test files specified");
        return Ok(());
    }
    
    for file in files {
        if !file.exists() {
            eprintln!("Warning: Test file {:?} does not exist", file);
            continue;
        }
        
        println!("Running tests in: {:?}", file);
        
        // TODO: Implement test runner
        let source = fs::read_to_string(&file)?;
        let tokens: Vec<_> = lexer::PositionalLexer::new(&source).collect();
        let mut parser = parser::Parser::new(tokens);
        let ast = parser.parse()?;
        
        println!("Test file parsed successfully with {} items", ast.items.len());
    }
    
    Ok(())
}

fn check_command(files: Vec<PathBuf>) -> Result<()> {
    println!("Checking syntax for {} files", files.len());

    for file in files {
        if !file.exists() {
            eprintln!("Warning: File {:?} does not exist", file);
            continue;
        }
        
        let source = fs::read_to_string(&file)?;
        
        // Lex the source
        let tokens: Vec<_> = lexer::PositionalLexer::new(&source).collect();
        
        // Parse the source
        let mut parser = parser::Parser::new(tokens);
        match parser.parse() {
            Ok(ast) => {
                println!("✓ {:?}: Syntax OK ({} items)", file, ast.items.len());
            }
            Err(e) => {
                eprintln!("✗ {:?}: Syntax error: {}", file, e);
            }
        }
    }

    Ok(())
}

fn apex_command(input: PathBuf) -> Result<()> {
    println!("Evaluating APEXLANG source: {:?}", input);
    let source = fs::read_to_string(&input)?;
    let value = apexlang::evaluate_source(&source)?;
    println!("Result: {}", value);
    Ok(())
}
